package fr.upem.hireanemployee.converters;


import fr.upem.hireanemployee.Logger;

/**
 * This class is intended to walk around a JSF bug.
 * If you have multiple form, checkboxes, which can
 * be removed, generated by a foreach loop, a bug
 * will be generated when removing one of them.
 * Future commands on one a the direct sibling of the
 * removed controller will match another one, because
 * indexes will be un synchronized. The solution is
 * to keep a list of the same size with a boolean
 * dead/not dead, to prevent the rendering of removed
 * objects, and continue to provide the right count
 * for JSF indexations. When a future rendering of the
 * whole list is made, all the removed objects can be
 * removed from their list since JSF will re-index everything.
 * This does not apply for checkboxes where the behaviour
 * is more problematic. If you delete one object on a clic,
 * even if your render again all the list of checkboxes,
 * the next in line will be click too.
 *
 * @Note : We don't know what generate
 * this sort of behaviour in JSF, and it is very
 * against intuitive. But we know for sure that's the reason
 * many people are waiting for the Mojarra 3.0 nor switching
 * on new abstractions like PrimeFaces or OmniFaces.
 */
public class FormControlWrapper<T> extends Logger {

    private final T wrapped;
    private boolean isDead;

    public FormControlWrapper(T wrapped) {
        this.wrapped = wrapped;
    }

    public T get() {
        return wrapped;
    }

    public boolean isDead() {
        return isDead;
    }

    public void setDead(boolean dead) {
        isDead = dead;
    }

    @Override
    public String toString() {
        return wrapped.toString();
    }

    @Override
    public boolean equals(Object obj) {
        // Delegating.
        if (!(obj instanceof FormControlWrapper)) {
            return false;
        }
        return wrapped.equals(((FormControlWrapper) obj).get());
    }
}
